好的，我来给你详细讲解后面三个模块。我会用**生活化的例子**配合**代码**来解释。

---

## 一、符号表 (SymTable) - "变量登记簿"

### 1.1 为什么需要符号表？

想象你是一个仓库管理员，每次有货物进来，你需要登记：
- 货物名称是什么？
- 放在哪个货架？
- 是什么类型的货物？

**符号表就是编译器的"登记簿"**，记录程序中的每个变量/常量/过程。

### 1.2 符号表存什么？

```pascal
program test;
const PI := 3;        // 常量
var x, y;             // 变量
procedure add(a, b);  // 过程，有两个形参
    var result;       // 过程内的局部变量
    begin ... end;
begin
    ...
end
```

符号表长这样：

| 位置 | 名称 | 类型 | 层级 | 偏移/值 | 说明 |
|------|------|------|------|---------|------|
| 0 | test | 过程 | 0 | 入口=1 | 主程序 |
| 1 | PI | 常量 | 0 | 值=3 | |
| 2 | x | 变量 | 0 | 偏移=0 | |
| 3 | y | 变量 | 0 | 偏移=4 | |
| 4 | add | 过程 | 0 | 入口=5 | |
| 5 | a | 形参 | 1 | 偏移=0 | add的形参 |
| 6 | b | 形参 | 1 | 偏移=4 | add的形参 |
| 7 | result | 变量 | 1 | 偏移=8 | add的局部变量 |

### 1.3 "层级"是什么意思？

```pascal
program main;           // 层级 0
    procedure A();      // 层级 1（在main里面）
        procedure B();  // 层级 2（在A里面）
        begin ... end;
    begin ... end;
begin ... end
```

**层级 = 嵌套深度**。就像俄罗斯套娃，外面的是 0 层，往里一层就 +1。

### 1.4 符号表的核心操作

**插入符号** (`InsertToTable`)：
```cpp
// 当 parser 分析到 "var x" 时
symTable.InsertToTable("x", 偏移量, VAR);
// 相当于：登记一个叫 x 的变量
```

**查找符号** (`SearchInfo`)：
```cpp
// 当 parser 分析到 "x := 10" 时
int pos = symTable.SearchInfo("x", VAR);
// 问：x 在符号表的哪个位置？
// 这样才能知道 x 的地址，生成正确的 P-Code
```

### 1.5 Display 表 - 快速找到各层的变量

```
假设现在在 B 过程里（层级2），要访问 main 里的变量 x

Display 表：
display[0] = 3  → 指向层级0最新的符号（y的位置）
display[1] = 7  → 指向层级1最新的符号（result的位置）
display[2] = ...

查找 x 的过程：
1. 从 display[2] 开始，沿着 previous 链往前找，没找到
2. 从 display[1] 开始，沿着 previous 链往前找，没找到
3. 从 display[0] 开始，找到 x 在位置 2！
```

---

## 二、P-Code 生成 - "翻译成机器指令"

### 2.1 什么是 P-Code？

P-Code 是一种**虚拟机指令**，就像"简化版汇编语言"。

真实 CPU 有寄存器，很复杂。P-Code 用**栈**来做所有计算，非常简单。

### 2.2 栈式计算 - 用栈做加减乘除

假设要计算 `3 + 5`：

```
普通计算器思维：3 + 5 = 8

栈式计算：
第1步：把 3 放进栈    栈: [3]
第2步：把 5 放进栈    栈: [3, 5]
第3步：弹出两个数，相加，结果入栈    栈: [8]
```

**这就是 P-Code 的核心思想！**

### 2.3 P-Code 指令详解

| 指令 | 例子 | 含义（用栈来理解） |
|------|------|-------------------|
| **LIT** | `LIT 0, 5` | 把常量 5 压入栈顶 |
| **LOD** | `LOD 0, 3` | 把某个变量的值压入栈顶 |
| **STO** | `STO 0, 3` | 把栈顶的值存到某个变量 |
| **OPR** | `OPR 0, 2` | 弹出栈顶两个数，做运算，结果入栈 |
| **JMP** | `JMP 0, 10` | 跳转到第 10 条指令 |
| **JPC** | `JPC 0, 10` | 如果栈顶是 0（假），就跳转 |

### 2.4 完整例子：`a := b + 2`

假设：
- 变量 `a` 在偏移量 3 的位置
- 变量 `b` 在偏移量 4 的位置

**生成的 P-Code：**

```
LOD 0, 4    // 把 b 的值压入栈      栈: [b的值]
LIT 0, 2    // 把常量 2 压入栈      栈: [b的值, 2]
OPR 0, 2    // 加法运算             栈: [b的值+2]
STO 0, 3    // 存到 a               栈: []，a = b+2
```

### 2.5 if 语句怎么翻译？

```pascal
if x < 5 then
    y := 1
else
    y := 2
```

**生成的 P-Code：**

```
     LOD 0, 3     // 加载 x
     LIT 0, 5     // 常量 5
     OPR 0, 9     // 比较 x < 5，结果入栈（0或1）
     JPC 0, 8     // 如果栈顶是0（假），跳到第8条
     LIT 0, 1     // then分支：常量 1
     STO 0, 4     // 存到 y
     JMP 0, 10    // 跳过 else 分支
8:   LIT 0, 2     // else分支：常量 2
     STO 0, 4     // 存到 y
10:  ...          // 继续
```

**流程图：**
```
        条件判断 (x < 5)
              │
      ┌───────┴───────┐
      │ 真           │ 假 (JPC跳转)
      ▼               ▼
   y := 1          y := 2
      │               │
      └───────┬───────┘
              ▼
           继续执行
```

### 2.6 while 循环怎么翻译？

```pascal
while x < 10 do
    x := x + 1
```

**生成的 P-Code：**

```
0:   LOD 0, 3     // 循环开始：加载 x
     LIT 0, 10    // 常量 10
     OPR 0, 9     // 比较 x < 10
     JPC 0, 9     // 如果假，跳出循环到第9条
     LOD 0, 3     // 加载 x
     LIT 0, 1     // 常量 1
     OPR 0, 2     // x + 1
     STO 0, 3     // 存回 x
     JMP 0, 0     // 跳回循环开始
9:   ...          // 循环结束，继续
```

### 2.7 回填技术

问题：生成 `JPC 0, ?` 时，还不知道跳转目标是多少！

解决：
```cpp
// 先生成，地址填 0
int jpc_addr = emit(jpc, 0, 0);  // 返回这条指令的位置

// 继续生成其他代码...

// 现在知道目标地址了，回填！
backpatch(jpc_addr, 当前地址);
```

---

## 三、解释器 (Interpreter) - "执行 P-Code"

### 3.1 解释器的三个寄存器

```cpp
size_t pc;   // 程序计数器：当前执行到哪条指令
size_t sp;   // 栈基址：当前活动记录的起始位置
size_t top;  // 栈顶：数据栈的顶部
```

### 3.2 运行栈的结构

想象一个**竖直的杯子**，数据从底部往上堆：

```
地址    内容
 ↑
top→ 12    [临时计算值...]
     11    [局部变量 result = 15]
     10    [形参 b = 5]
     9     [形参 a = 3]
     8     [Display[1] = 0]
     7     [Display[0] = 0]
     6     [全局Display地址 = 6]
     5     [老SP = 0]
sp→  4     [返回地址 = 7]
     ─────────────────────
     3     [变量 y = 0]        ← 主程序的变量
     2     [变量 x = 0]
     1     [Display[0] = 0]
     0     [...]               ← 主程序的活动记录
```

### 3.3 每条指令怎么执行？

**LIT（加载常量）**
```cpp
void Interpreter::lit(Operation op, int L, int a) {
    running_stack[top] = a;  // 把常量 a 放到栈顶
    top++;                   // 栈顶上移
    pc++;                    // 执行下一条
}
```

**OPR（运算）**
```cpp
void Interpreter::opr(Operation op, int L, int a) {
    if (a == OPR_ADD) {
        // 加法：弹出两个数，相加，结果入栈
        int result = running_stack[top-2] + running_stack[top-1];
        running_stack[top-2] = result;
        top--;  // 两个数变一个
    }
    else if (a == OPR_RETURN) {
        // 返回：恢复现场
        pc = running_stack[sp + 0];   // 恢复返回地址
        top = sp;                      // 弹出活动记录
        sp = running_stack[sp + 1];   // 恢复老 SP
        return;
    }
    // ... 其他运算
    pc++;
}
```

**LOD（加载变量）**
```cpp
void Interpreter::lod(Operation op, int L, int a) {
    // L = 层差（当前层 - 变量所在层）
    // a = 变量在那一层的偏移
    
    // 1. 找到目标层的基地址
    int base = running_stack[sp + 3 + L];  // 从 Display 表找
    
    // 2. 取出变量值
    running_stack[top] = running_stack[base + a];
    top++;
    pc++;
}
```

### 3.4 过程调用的完整过程

```pascal
program main;
var x;
procedure foo(a);
    begin write(a) end;
begin
    x := 10;
    call foo(x)    // ← 调用发生在这里
end
```

**调用前的栈：**
```
top→ 5  [x的值 = 10]  ← 刚计算出来的实参
     4  [x = 10]
     3  [Display[0] = 0]
     2  [全局Display地址]
     1  [老SP = 0]
sp→  0  [返回地址]
```

**CAL 指令执行：**
```cpp
void Interpreter::cal(Operation op, int L, int a) {
    // 1. 保存返回地址
    running_stack[top + 0] = pc + 1;
    
    // 2. 保存老 SP
    running_stack[top + 1] = sp;
    
    // 3. 复制 Display 表
    running_stack[top + 3] = 0;  // Display[0]
    running_stack[top + 4] = top;  // Display[1] = 新活动记录基址
    
    // 4. 更新寄存器
    sp = top;
    pc = a;  // 跳转到 foo 的入口
}
```

**调用后的栈：**
```
top→ 11 [...]
     10 [形参 a = 10]      ← 新的活动记录
     9  [Display[1] = 6]
     8  [Display[0] = 0]
     7  [全局Display地址 = 8]
     6  [老SP = 0]
sp→  5  [返回地址 = 下一条]
     ─────────────────────
     4  [x = 10]           ← 主程序的活动记录
     3  [Display[0] = 0]
     2  [全局Display地址]
     1  [老SP = 0]
     0  [返回地址]
```

### 3.5 解释器主循环

```cpp
void Interpreter::run() {
    Init();  // pc=0, sp=0, top=0
    
    while (还有指令) {
        PCode code = pcodelist.code_list[pc];  // 取当前指令
        
        switch (code.op) {
            case lit:  lit(code.op, code.L, code.a); break;
            case opr:  opr(code.op, code.L, code.a); break;
            case load: lod(code.op, code.L, code.a); break;
            case store:sto(code.op, code.L, code.a); break;
            case call: cal(code.op, code.L, code.a); break;
            case alloc:alc(code.op, code.L, code.a); break;
            case jmp:  jmp(code.op, code.L, code.a); break;
            case jpc:  jpc(code.op, code.L, code.a); break;
            case red:  red(code.op, code.L, code.a); break;
            case wrt:  wrt(code.op, code.L, code.a); break;
        }
    }
}
```

---

## 四、完整例子演示

```pascal
program demo;
var a, b;
begin
    a := 3;
    b := a + 2;
    write(b)
end
```

### Step 1: 词法分析
```
[PROGRAM] [IDENT:demo] [SEMICOLON] [VAR] [IDENT:a] [COMMA] [IDENT:b] [SEMICOLON] ...
```

### Step 2: 语法分析 + 符号表
```
符号表:
| 位置 | 名称 | 类型 | 层级 | 偏移 |
|------|------|------|------|------|
| 0    | demo | PROC | 0    | -    |
| 1    | a    | VAR  | 0    | 0    |
| 2    | b    | VAR  | 0    | 4    |
```

### Step 3: P-Code 生成
```
0:  JMP  0, 1     // 跳到主程序入口（回填的）
1:  INT  0, 6     // 分配空间：3(固定) + 1(display) + 2(变量)
2:  LIT  0, 3     // 常量 3
3:  STO  0, 4     // 存到 a（偏移4 = 3+1+0）
4:  LOD  0, 4     // 加载 a
5:  LIT  0, 2     // 常量 2
6:  OPR  0, 2     // 加法
7:  STO  0, 5     // 存到 b（偏移5 = 3+1+1）
8:  LOD  0, 5     // 加载 b
9:  WRT  0, 0     // 输出
10: OPR  0, 13    // 换行
11: OPR  0, 0     // 返回（程序结束）
```

### Step 4: 解释执行
```
pc=0: JMP → pc=1
pc=1: INT → 分配6个空间，栈: [0,0,0,0,0,0], top=6
pc=2: LIT 3 → 栈: [..., 3], top=7
pc=3: STO → 栈[4]=3, 栈: [0,0,0,0,3,0], top=6
pc=4: LOD → 取栈[4], 栈: [..., 3], top=7
pc=5: LIT 2 → 栈: [..., 3, 2], top=8
pc=6: OPR + → 3+2=5, 栈: [..., 5], top=7
pc=7: STO → 栈[5]=5, 栈: [0,0,0,0,3,5], top=6
pc=8: LOD → 取栈[5], 栈: [..., 5], top=7
pc=9: WRT → 输出 "write: 5", top=6
pc=10: OPR 13 → 输出换行
pc=11: OPR 0 → 返回，程序结束
```

**输出：** `write: 5`

---

## 总结一句话

| 模块 | 干什么 | 类比 |
|------|--------|------|
| **符号表** | 记录变量的名字、类型、位置 | 仓库登记簿 |
| **P-Code生成** | 把高级语言翻译成栈指令 | 把中文翻译成机器语言 |
| **解释器** | 逐条执行P-Code指令 | CPU执行机器码 |

有哪部分还不清楚的，告诉我！